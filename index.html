<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Heat Swim</title>
  <style>
    :root {
      --bg: #061624;
      --panel: #0b2236;
      --panel-2: #0f2a42;
      --text: #e6f2ff;
      --muted: #9db6c9;
      --accent: #35c6c6;
      --accent-2: #1aa0ff;
      --danger: #ff6b6b;
      --success: #45d483;
      --warning: #ffd166;
      --focus: #f8ff95;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 70% -10%, #123a5c 0%, transparent 60%),
                  radial-gradient(900px 700px at 10% 10%, #0b2b3b 0%, transparent 55%),
                  linear-gradient(180deg, #040c14 0%, #061624 60%, #081b2b 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    .app {
      width: min(980px, 100%);
      background: rgba(6, 22, 36, 0.9);
      border: 1px solid #0e2a40;
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.45);
      overflow: hidden;
    }

    header {
      padding: 16px 20px;
      background: linear-gradient(90deg, #0b2236 0%, #0f2c45 60%, #0b2236 100%);
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid #0f2a42;
    }

    header h1 {
      margin: 0;
      font-size: 1.4rem;
      letter-spacing: 0.5px;
    }

    .screen {
      display: none;
      padding: 18px 20px 22px;
    }

    .screen.active { display: block; }

    .grid {
      display: grid;
      gap: 14px;
    }

    .grid.two {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .panel {
      background: var(--panel);
      border: 1px solid #12314b;
      border-radius: 12px;
      padding: 14px;
    }

    label { display: block; font-size: 0.95rem; margin-bottom: 6px; }

    select, input[type="number"], input[type="text"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #1b3b55;
      background: #0b2033;
      color: var(--text);
      font-size: 1rem;
    }

    input[type="text"]::placeholder { color: #7fa0b8; }

    .btn {
      border: none;
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 1rem;
      cursor: pointer;
      background: #14334d;
      color: var(--text);
      transition: transform 0.12s ease, background 0.2s ease;
      min-height: 46px;
    }

    .btn:hover { background: #174261; }
    .btn:active { transform: scale(0.98); }
    .btn.primary { background: linear-gradient(135deg, var(--accent-2), var(--accent)); color: #061624; font-weight: 700; }
    .btn.danger { background: #3a1b24; color: #ffb3b3; border: 1px solid #6c2433; }
    .btn.ghost { background: transparent; border: 1px solid #1b3b55; color: var(--muted); }

    .btn:focus, select:focus, input:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }

    .turn-banner {
      padding: 10px 12px;
      border-radius: 10px;
      background: #0f2f47;
      border: 1px solid #183c58;
      font-weight: 600;
    }

    #actionPanel {
      transition: background 0.2s ease, border-color 0.2s ease;
    }

    .turn-overlay {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 16px 18px;
      border-radius: 14px;
      background: rgba(6, 22, 36, 0.95);
      border: 1px solid #1b3b55;
      box-shadow: 0 16px 40px rgba(0,0,0,0.55);
      color: var(--text);
      font-size: 0.98rem;
      opacity: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 60;
      width: min(680px, 92%);
      text-align: left;
    }

    .turn-overlay.show {
      opacity: 1;
      transform: translate(-50%, -52%);
      pointer-events: auto;
    }

    #turnOverlayText {
      display: grid;
      gap: 6px;
    }

    .summary-line {
      background: rgba(10, 30, 46, 0.6);
      border: 1px solid #12314b;
      padding: 6px 8px;
      border-radius: 8px;
    }

    .summary-actions {
      display: flex;
      justify-content: flex-end;
    }

    .player-card {
      display: grid;
      gap: 8px;
      padding: 10px;
      background: #0b2033;
      border: 1px solid #14324a;
      border-radius: 10px;
    }

    .player-card .row {
      display: flex;
      justify-content: space-between;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .progress {
      height: 12px;
      background: #0c2a40;
      border-radius: 999px;
      position: relative;
      overflow: hidden;
    }

    .progress .fill {
      height: 100%;
      border-radius: 999px;
      transition: width 0.2s ease;
    }

    .progress .marker {
      position: absolute;
      top: -3px;
      width: 14px;
      height: 18px;
      border-radius: 8px;
      background: #e6f2ff;
      border: 2px solid #091c2c;
      transform: translateX(-50%);
    }

    .actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }

    .actions .btn { font-weight: 700; }

    .actions .btn.small { font-size: 0.95rem; }

    .log {
      max-height: 160px;
      overflow: hidden;
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .log-line { padding: 6px 8px; border-radius: 8px; background: #0a1d2e; border: 1px solid #122f46; }

    .track-board {
      position: relative;
      height: 380px;
      border-radius: 16px;
      background:
        radial-gradient(160px 160px at 20% 30%, rgba(255,255,255,0.18), transparent 60%),
        radial-gradient(180px 180px at 80% 60%, rgba(255,255,255,0.15), transparent 60%),
        radial-gradient(220px 220px at 60% 20%, rgba(0, 160, 255, 0.25), transparent 65%),
        repeating-linear-gradient(130deg, rgba(255,255,255,0.04) 0 6px, transparent 6px 14px),
        linear-gradient(135deg, #0b2b4a, #0c3a63 40%, #0a2440);
      border: 1px solid #0a1d2f;
      overflow: hidden;
    }

    .track-svg {
      position: absolute;
      inset: 28px;
      width: calc(100% - 56px);
      height: calc(100% - 56px);
      z-index: 1;
    }

    .track-path.edge {
      fill: none;
      stroke: #0c2f48;
      stroke-width: 20;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.9;
    }

    .track-path.outer {
      fill: none;
      stroke: #071e30;
      stroke-width: 14;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .track-path.turn-texture {
      fill: none;
      stroke: rgba(176, 226, 248, 0.22);
      stroke-width: 2;
      stroke-linecap: round;
      stroke-dasharray: 1 48;
      animation: turn-dot 3.4s linear infinite;
    }

    .track-path.turn-texture.soft {
      stroke: rgba(120, 210, 235, 0.28);
    }

    .track-path.turn-texture.medium {
      stroke: rgba(120, 220, 255, 0.36);
    }

    .track-path.turn-texture.hard {
      stroke: rgba(160, 230, 255, 0.46);
    }

    @keyframes turn-dot {
      to { stroke-dashoffset: -50; }
    }

    .track-node {
      position: absolute;
      width: 24px;
      height: 24px;
      border-radius: 6px;
      background: #0a2b45;
      border: 1px solid #1a4d73;
      color: #e6f2ff;
      font-size: 0.72rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translate(-50%, -50%);
      z-index: 9;
    }

    .track-node.turn {
      box-shadow: inset 0 0 0 2px #1aa0ff;
    }

    .track-node.turn::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: 8px;
      border: 2px dashed rgba(26, 160, 255, 0.65);
      pointer-events: none;
    }

    .track-node.next-turn {
      box-shadow: inset 0 0 0 2px #ffd166, 0 0 10px rgba(255, 209, 102, 0.6);
    }

    .track-node.next-turn::after {
      border-color: rgba(255, 209, 102, 0.9);
    }

    .track-node.finish {
      background: #0f3a4a;
      border-color: #35c6c6;
      color: #bfffd6;
    }

    .track-node.turn.diff-1 {
      border-color: #6fe6b8;
      box-shadow: inset 0 0 0 2px #6fe6b8;
    }

    .track-node.turn.diff-2 {
      border-color: #6cc6ff;
      box-shadow: inset 0 0 0 2px #6cc6ff;
    }

    .track-node.turn.diff-3 {
      border-color: #ff9b6f;
      box-shadow: inset 0 0 0 2px #ff9b6f;
    }

    .turn-limit {
      position: absolute;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.3px;
      background: rgba(6, 22, 36, 0.9);
      border: 1px dashed rgba(255, 191, 102, 0.9);
      color: #ffbf66;
      transform: translate(-50%, -50%);
      z-index: 7;
    }

    .turn-limit.diff-1 {
      border-color: rgba(110, 230, 184, 0.9);
      color: #6fe6b8;
    }

    .turn-limit.diff-2 {
      border-color: rgba(108, 198, 255, 0.9);
      color: #6cc6ff;
    }

    .turn-limit.diff-3 {
      border-color: rgba(255, 155, 111, 0.9);
      color: #ff9b6f;
    }

    .track-marker {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #061624;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      font-weight: 700;
      color: #061624;
      transform: translate(-50%, -50%);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      z-index: 10;
    }

    .track-marker.current {
      box-shadow: 0 0 12px rgba(53, 198, 198, 0.8);
    }

    .track-label {
      position: absolute;
      padding: 2px 6px;
      border-radius: 6px;
      background: rgba(6, 22, 36, 0.7);
      border: 1px solid #1b3b55;
      color: var(--text);
      font-size: 0.75rem;
      transform: translate(-50%, -50%);
      z-index: 11;
    }

    .track-label.finish {
      padding: 4px 8px;
      font-weight: 700;
      border-radius: 8px;
      background: linear-gradient(135deg, #111 0%, #111 25%, #f5f5f5 25%, #f5f5f5 50%, #111 50%, #111 75%, #f5f5f5 75%, #f5f5f5 100%);
      background-size: 12px 12px;
      color: #061624;
      border: 2px solid #1aa0ff;
      box-shadow: 0 0 10px rgba(26, 160, 255, 0.6);
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(3, 10, 16, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 30;
    }

    .modal.active { display: flex; }

    .modal-content {
      width: min(520px, 100%);
      background: #0b2236;
      border: 1px solid #1c3e5a;
      border-radius: 14px;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    #modal-tutorial .modal-content {
      max-height: 90vh;
      overflow: auto;
    }

    #modal-tutorial .row.space {
      position: sticky;
      top: 0;
      background: #0b2236;
      padding-top: 4px;
      z-index: 2;
    }

    #modal-tutorial #tutorialDone {
      position: sticky;
      bottom: 0;
      z-index: 2;
    }

    #eventTone {
      font-weight: 700;
      color: #061624;
      background: linear-gradient(135deg, #7bff6b, #35c6c6);
      border-color: #7bff6b;
    }

    #eventTone.bad {
      background: linear-gradient(135deg, #ff9b6f, #ff4d6d);
      border-color: #ff9b6f;
    }

    .mini-close {
      display: none;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 0.85rem;
      background: #123049;
      color: var(--muted);
      border: 1px solid #1b3b55;
    }

    .mini-bar {
      position: relative;
      height: 18px;
      background: #0c2a40;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #173954;
    }

    .mini-bar .target {
      position: absolute;
      top: 0;
      height: 100%;
      background: #1a9f84;
      border: 1px solid #58e4c2;
    }

    .mini-bar .cursor {
      position: absolute;
      top: -4px;
      width: 10px;
      height: 26px;
      background: #f8ff95;
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(248,255,149,0.6);
    }

    .results-list {
      display: grid;
      gap: 10px;
    }

    .result-row {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background: #0b2033;
      border: 1px solid #14324a;
      border-radius: 10px;
      font-size: 0.95rem;
    }

    .record {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .help {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .track-panel {
      padding-bottom: 22px;
    }

    .lane {
      display: grid;
      gap: 4px;
      align-items: center;
    }

    .lap {
      height: 12px;
      background: #0c2a40;
      border: 1px solid #12314b;
      border-radius: 4px;
    }

    .lap.done {
      background: linear-gradient(90deg, #1aa0ff, #35c6c6);
      border-color: #1aa0ff;
    }

    .lap.turn {
      box-shadow: inset 0 0 0 1px #1aa0ff;
    }

    .lap.next {
      outline: 2px solid var(--warning);
      outline-offset: 1px;
    }

    .legend {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .tutorial-steps {
      margin: 0;
      padding-left: 18px;
      display: grid;
      gap: 8px;
      color: var(--text);
      font-size: 0.95rem;
    }

    .tutorial-steps li {
      background: #0a1d2e;
      border: 1px solid #122f46;
      padding: 8px 10px;
      border-radius: 8px;
      list-style-position: inside;
    }

    .turn-indicator {
      font-weight: 700;
      color: var(--accent);
    }

    .badge {
      padding: 2px 6px;
      border-radius: 6px;
      font-size: 0.8rem;
      background: #1b3b55;
      color: #e6f2ff;
    }

    .row { display: flex; gap: 10px; align-items: center; }

    .row.space { justify-content: space-between; }

    .muted { color: var(--muted); }

    @media (max-width: 700px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .row.space { flex-direction: column; align-items: flex-start; }
      .actions { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Heat Swim">
    <header>
      <h1>Heat Swim</h1>
      <div class="tag" id="headerHint">Juego r√°pido de piscina nocturna</div>
    </header>

    <section class="screen active" id="screen-config" aria-labelledby="config-title">
      <div class="grid two">
        <div class="panel">
          <h2 id="config-title">Configuraci√≥n</h2>
          <div class="grid">
            <div>
              <label for="distance">Distancia (largos)</label>
              <select id="distance">
                <option value="10">10</option>
                <option value="12" selected>12</option>
                <option value="14">14</option>
                <option value="16">16</option>
              </select>
            </div>
            <div>
              <label for="turnCount">N√∫mero de virajes</label>
              <select id="turnCount"></select>
              <div class="muted" id="turnIntervalHint"></div>
            </div>
            <div>
              <label for="energy">Energ√≠a inicial</label>
              <input id="energy" type="number" min="6" max="14" value="10" />
            </div>
            <div>
              <label for="energyMax">Energ√≠a m√°xima (bonus)</label>
              <input id="energyMax" type="number" min="8" max="16" value="12" />
            </div>
            <div>
              <label for="players">Jugadores</label>
              <select id="players">
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
            </div>
          </div>
        </div>
        <div class="panel">
          <h2>Jugadores</h2>
          <div id="playerInputs" class="grid"></div>
          <div class="help">
            Teclas: 1 Suave, 2 Fuerte, 3 Sprint, Enter Confirmar, Esc Cerrar modales.
          </div>
          <div class="row space" style="margin-top:10px;">
            <button class="btn danger" id="resetData">Reset data</button>
            <button class="btn ghost" id="openTutorial">Tutorial</button>
            <button class="btn primary" id="startGame">Comenzar</button>
          </div>
        </div>
      </div>
    </section>

    <section class="screen" id="screen-game" aria-labelledby="game-title">
      <div class="grid">
        <div class="panel">
          <div class="row space">
            <div>
              <h2 id="game-title">Carrera</h2>
              <div class="muted">Distancia: <span id="gameDistance">0</span> largos ¬∑ Virajes: <span id="gameTurns">0</span></div>
            </div>
            <div class="turn-banner">Turno: <span class="turn-indicator" id="turnName">-</span></div>
          </div>
        </div>
        <div class="panel track-panel">
          <div class="row space">
            <div>Pista Heat Swim</div>
            <div class="badge">Meta: <span id="trackDistance">0</span> largos</div>
          </div>
          <div class="track-board" id="trackBoard"></div>
          <div class="legend">Virajes: borde azul. Pr√≥ximo viraje del jugador actual: borde amarillo.</div>
          <div class="legend" id="turnList"></div>
        </div>
        <div class="panel">
          <div id="playerBoard" class="grid"></div>
        </div>
        <div class="panel" id="actionPanel">
          <div class="row space">
            <div>
              <div class="muted">Acciones</div>
              <div class="muted" id="blockedHint"></div>
            </div>
            <div class="badge" id="turnCounter">Turno 1</div>
          </div>
          <div class="actions" id="actionButtons">
            <button class="btn" data-action="soft">1 ¬∑ Suave</button>
            <button class="btn" data-action="strong">2 ¬∑ Fuerte</button>
            <button class="btn" data-action="sprint">3 ¬∑ Sprint</button>
          </div>
        </div>
        <div class="panel">
          <div class="row space">
            <div>Log del turno</div>
            <button class="btn ghost" id="openHelp">Ayuda</button>
          </div>
          <div class="log" id="log"></div>
        </div>
      </div>
      <div class="turn-overlay" id="turnOverlay" role="dialog" aria-live="polite">
        <div id="turnOverlayText"></div>
        <div class="summary-actions">
          <button class="btn ghost" id="turnOverlayClose">Cerrar</button>
        </div>
      </div>
    </section>

    <section class="screen" id="screen-results" aria-labelledby="results-title">
      <div class="grid">
        <div class="panel">
          <h2 id="results-title">Resultados</h2>
          <div class="result-row">
            <strong id="winnerName">Ganador</strong>
            <span id="winnerMeta"></span>
          </div>
          <div class="record" id="recordInfo"></div>
        </div>
        <div class="panel">
          <h3>Clasificaci√≥n</h3>
          <div class="results-list" id="resultsList"></div>
        </div>
        <div class="panel">
          <h3>Historial reciente</h3>
          <div class="results-list" id="historyList"></div>
          <div class="row" style="margin-top:10px;">
            <button class="btn ghost" id="backToConfig">Nueva partida</button>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="modal" id="modal-trivia" aria-modal="true" role="dialog" aria-labelledby="trivia-title">
    <div class="modal-content">
      <div class="row space">
        <h3 id="trivia-title">Trivia</h3>
        <button class="btn ghost" id="closeTrivia">Esc</button>
      </div>
      <div class="tag" id="triviaCategory">Categor√≠a</div>
      <div id="triviaQuestion">Pregunta</div>
      <div class="grid" id="triviaOptions"></div>
      <div class="muted" id="triviaFeedback"></div>
    </div>
  </div>

  <div class="modal" id="modal-minigame" aria-modal="true" role="dialog" aria-labelledby="minigame-title">
      <div class="modal-content">
        <div class="row space">
          <h3 id="minigame-title">Viraje</h3>
          <button class="btn ghost mini-close" id="closeMini">Esc</button>
        </div>
        <div class="muted">Det√©n el cursor dentro de la zona verde</div>
        <div class="mini-bar" id="miniBar">
          <div class="target" id="miniTarget"></div>
          <div class="cursor" id="miniCursor"></div>
        </div>
        <button class="btn primary" id="miniStop">Detener (Enter)</button>
        <div class="muted" id="miniFeedback"></div>
      </div>
    </div>

  <div class="modal" id="modal-event" aria-modal="true" role="dialog" aria-labelledby="event-title">
    <div class="modal-content">
      <div class="row space">
        <h3 id="event-title">Evento</h3>
        <button class="btn ghost" id="closeEvent">Cerrar</button>
      </div>
      <div class="tag" id="eventTone">Perfecto</div>
      <div id="eventMessage"></div>
    </div>
  </div>

  <div class="modal" id="modal-help" aria-modal="true" role="dialog" aria-labelledby="help-title">
    <div class="modal-content">
      <div class="row space">
        <h3 id="help-title">Ayuda r√°pida</h3>
        <button class="btn ghost" id="closeHelp">Esc</button>
      </div>
      <div class="help">
        Elige acci√≥n para avanzar. El turno avanza autom√°ticamente tras un breve resumen. Todos los jugadores est√°n en la misma pista azul. En virajes ver√°s MAX 1/2/3 (dificultad); Sprint = curva m√°s dif√≠cil. El Sprint puede activar trivia. Cruzar un viraje abre mini-juego; acertar suma +1 largo, fallar resta -1. Gana quien llegue primero a la meta.
      </div>
    </div>
  </div>

  <div class="modal" id="modal-tutorial" aria-modal="true" role="dialog" aria-labelledby="tutorial-title">
    <div class="modal-content">
      <div class="row space">
        <h3 id="tutorial-title">Tutorial r√°pido</h3>
        <button class="btn ghost" id="closeTutorial">Esc</button>
      </div>
      <div class="tag">5 pasos para empezar</div>
      <ol class="tutorial-steps">
        <li>Elige una acci√≥n: Suave (+1), Fuerte (+2), Sprint (+3).</li>
        <li>Tras la acci√≥n ver√°s un resumen y el turno avanza autom√°ticamente.</li>
        <li>La energ√≠a baja con Fuerte y Sprint. Si llega a 0, quedas bloqueado (solo Suave).</li>
        <li>Todos comparten la misma pista. Los virajes est√°n marcados (borde azul); el pr√≥ximo viraje del turno actual se resalta en amarillo.</li>
        <li>En virajes ver√°s MAX 1/2/3 (dificultad). Sprint hace la zona m√°s dif√≠cil.</li>
        <li>Al cruzar un viraje aparece el mini-juego: det√©n el cursor en la zona verde.</li>
        <li>Si aciertas el viraje: +1 largo y trivia. Si fallas: -1 largo.</li>
        <li>Los Sprint pueden abrir trivia; si aciertas, ganas +1 energ√≠a (hasta el m√°ximo).</li>
        <li>Gana quien llegue primero a la meta. En empate: menos turnos, luego m√°s energ√≠a.</li>
      </ol>
      <button class="btn primary" id="tutorialDone">Entendido (Enter)</button>
    </div>
  </div>

  <script>
    const state = {
      screen: 'config',
      config: {
        distance: 12,
        turnCount: 3,
        energy: 10,
        energyMax: 12,
        players: 2
      },
      players: [],
      currentIndex: 0,
      log: [],
      blockedNext: {},
      blockReason: {},
      blockedSkip: {},
      turnLaps: [],
      turnDifficulties: {},
      awaiting: null,
      turnSummary: null,
      trivia: null,
      miniGame: null,
      collectingSummary: false,
      turnSummaryLines: [],
      turnSummaryTimer: null,
      turnSummaryPlayer: null,
      turnNumber: 1,
      records: {},
      history: []
    };

    const colors = ['#00e5ff', '#ff4d6d', '#ffd166', '#7bff6b'];
    const icons = ['üèä', 'üèä‚Äç‚ôÄÔ∏è', 'ü§ø', 'üê¨'];

    const questions = [
      { q: '¬øQu√© significa ‚Äústreamlining‚Äù en nataci√≥n?', a: ['Reducir resistencia en posici√≥n hidrodin√°mica', 'Aumentar frecuencia de brazada', 'Respirar cada dos brazadas'], c: 0, cat: 'T√©cnica' },
      { q: '¬øCu√°l es el l√≠mite de subacu√°tico tras salida/viraje en mariposa, espalda y libre?', a: ['10 m', '15 m', '25 m'], c: 1, cat: 'Reglas' },
      { q: 'En relevos combinados, el orden de estilos es:', a: ['Espalda, braza, mariposa, libre', 'Libre, mariposa, espalda, braza', 'Braza, espalda, mariposa, libre'], c: 0, cat: 'Reglas' },
      { q: 'Un viraje eficiente busca principalmente:', a: ['Maximizar tiempo en pared', 'Minimizar tiempo sin propulsi√≥n', 'Respirar m√°s'], c: 1, cat: 'T√©cnica' },
      { q: '¬øQu√© estilo fue el primero en competencias ol√≠mpicas modernas?', a: ['Libre (crol)', 'Mariposa', 'Espalda'], c: 0, cat: 'Historia' },
      { q: 'La ‚Äúpatada subacu√°tica‚Äù m√°s asociada con espalda se denomina:', a: ['Patada de delf√≠n', 'Patada de tijera', 'Patada de rana'], c: 0, cat: 'T√©cnica' },
      { q: 'El traje de cuerpo completo de poliuretano fue restringido por FINA en:', a: ['2000', '2010', '2020'], c: 1, cat: 'Historia' },
      { q: 'La frecuencia de brazada alta con poca longitud suele:', a: ['Fatigar m√°s r√°pido', 'Ahorrar energ√≠a siempre', 'Ser m√°s hidrodin√°mica'], c: 0, cat: 'T√©cnica' },
      { q: '¬øCu√°l es la distancia t√≠pica de piscina ol√≠mpica?', a: ['25 m', '50 m', '100 m'], c: 1, cat: 'Historia' },
      { q: 'En braza, durante el viraje se requiere:', a: ['Tocar con una mano', 'Tocar con dos manos simult√°neamente', 'No tocar'], c: 1, cat: 'Reglas' },
      { q: 'En espalda, la salida se realiza:', a: ['Desde el bloque', 'Desde el agua', 'Con salto lateral'], c: 1, cat: 'Reglas' },
      { q: 'Una salida ‚Äúexplosiva‚Äù se beneficia de:', a: ['√Ångulo de entrada controlado', 'Entrada plana', 'Mirar arriba'], c: 0, cat: 'T√©cnica' },
      { q: '¬øQu√© estilo se separ√≥ de la braza para convertirse en disciplina propia?', a: ['Mariposa', 'Espalda', 'Libre'], c: 0, cat: 'Historia' },
      { q: 'La fase ‚Äústreamline‚Äù ocurre:', a: ['Despu√©s del impulso de pared', 'En cada respiraci√≥n', 'Solo en braza'], c: 0, cat: 'T√©cnica' },
      { q: 'En libre, ¬øcu√°l es el l√≠mite de subacu√°tico?', a: ['5 m', '10 m', '15 m'], c: 2, cat: 'Reglas' },
      { q: 'Los r√©cords mundiales de 2009 fueron notables por:', a: ['Trajes tecnol√≥gicos avanzados', 'Piscinas m√°s cortas', 'Cambios de reglas en salida'], c: 0, cat: 'Historia' },
      { q: 'El ‚Äúflip turn‚Äù se usa principalmente en:', a: ['Crol y espalda', 'Braza y mariposa', 'Braza y libre'], c: 0, cat: 'T√©cnica' },
      { q: 'Una respiraci√≥n tard√≠a en crol suele:', a: ['Elevar caderas', 'Romper alineaci√≥n', 'Aumentar deslizamiento'], c: 1, cat: 'T√©cnica' },
      { q: '¬øCu√°l es la meta principal del ‚Äúunderwater kick‚Äù en mariposa?', a: ['Ganar velocidad sin resistencia de aire', 'Descansar brazos', 'Cambiar de estilo'], c: 0, cat: 'T√©cnica' },
      { q: 'El estilo espalda apareci√≥ en Juegos Ol√≠mpicos por primera vez en:', a: ['1900', '1920', '1956'], c: 0, cat: 'Historia' },
      { q: '¬øQu√© es un ‚Äúnegative split‚Äù?', a: ['Nadar m√°s r√°pido la segunda mitad', 'Nadar con respiraci√≥n unilateral', 'Cortar metros en virajes'], c: 0, cat: 'T√©cnica' },
      { q: 'El toque v√°lido en mariposa requiere:', a: ['Una mano', 'Dos manos simult√°neas', 'Ninguna mano'], c: 1, cat: 'Reglas' },
      { q: 'La eficiencia de brazada depende de:', a: ['Longitud y frecuencia equilibradas', 'Solo frecuencia alta', 'Solo fuerza'], c: 0, cat: 'T√©cnica' },
      { q: 'El estilo libre en competencias suele ser:', a: ['Crol', 'Braza', 'Espalda'], c: 0, cat: 'Historia' },
      { q: 'En espalda, al girar para el viraje:', a: ['Se permite un giro hacia el pecho', 'Est√° prohibido girar', 'Se toca con dos manos'], c: 0, cat: 'Reglas' },
      { q: 'Una entrada limpia al agua busca:', a: ['Minimizar salpicadura', 'Salpicar para intimidar', 'Entrar de lado'], c: 0, cat: 'T√©cnica' },
      { q: 'El relevo 4x100 combinado inicia con:', a: ['Espalda', 'Mariposa', 'Braza'], c: 0, cat: 'Reglas' },
      { q: 'El r√©cord ic√≥nico de 100m libre de 2008 es recordado por:', a: ['Final cerrada y gran cierre', 'Piscina corta', 'Descalificaci√≥n m√∫ltiple'], c: 0, cat: 'Historia' },
      { q: 'La patada de delf√≠n en libre es legal:', a: ['Solo despu√©s de salida/viraje hasta 15 m', 'En todo el largo', 'Nunca'], c: 0, cat: 'Reglas' },
      { q: 'La ‚Äúfrecuencia‚Äù de brazada se refiere a:', a: ['N√∫mero de ciclos por tiempo', 'Longitud de brazo', 'Cantidad de aire'], c: 0, cat: 'T√©cnica' },
      { q: 'La salida con reacci√≥n r√°pida se beneficia de:', a: ['Buen tiempo de reacci√≥n y fuerza en piernas', 'Respirar antes del salto', 'Mirar el reloj'], c: 0, cat: 'T√©cnica' },
      { q: 'El viraje de braza se diferencia por:', a: ['Tocar con dos manos y patada de rana', 'Giro de espalda', 'No tocar la pared'], c: 0, cat: 'Reglas' },
      { q: 'La evoluci√≥n de estilos en nataci√≥n competitiva se aceler√≥ por:', a: ['Mejores entrenamientos y ciencia del deporte', 'Menos competencias', 'Piscinas m√°s profundas'], c: 0, cat: 'Historia' },
      { q: 'El ‚Äúpull buoy‚Äù se usa para:', a: ['Aislar brazos y mejorar t√©cnica', 'Aumentar velocidad con motor', 'Cambiar de estilo'], c: 0, cat: 'T√©cnica' },
      { q: 'En 50m libre ol√≠mpico, normalmente:', a: ['No hay virajes', 'Hay un viraje', 'Hay dos virajes'], c: 0, cat: 'Historia' }
    ];

    const dom = {
      screens: {
        config: document.getElementById('screen-config'),
        game: document.getElementById('screen-game'),
        results: document.getElementById('screen-results')
      },
      distance: document.getElementById('distance'),
      turnCount: document.getElementById('turnCount'),
      turnIntervalHint: document.getElementById('turnIntervalHint'),
      energy: document.getElementById('energy'),
      energyMax: document.getElementById('energyMax'),
      players: document.getElementById('players'),
      playerInputs: document.getElementById('playerInputs'),
      startGame: document.getElementById('startGame'),
      resetData: document.getElementById('resetData'),
      gameDistance: document.getElementById('gameDistance'),
      gameTurns: document.getElementById('gameTurns'),
      turnName: document.getElementById('turnName'),
      playerBoard: document.getElementById('playerBoard'),
      trackBoard: document.getElementById('trackBoard'),
      trackDistance: document.getElementById('trackDistance'),
      turnList: document.getElementById('turnList'),
      actionButtons: document.getElementById('actionButtons'),
      actionPanel: document.getElementById('actionPanel'),
      blockedHint: document.getElementById('blockedHint'),
      turnCounter: document.getElementById('turnCounter'),
      log: document.getElementById('log'),
      openHelp: document.getElementById('openHelp'),
      openTutorial: document.getElementById('openTutorial'),
      modalTrivia: document.getElementById('modal-trivia'),
      triviaCategory: document.getElementById('triviaCategory'),
      triviaQuestion: document.getElementById('triviaQuestion'),
      triviaOptions: document.getElementById('triviaOptions'),
      triviaFeedback: document.getElementById('triviaFeedback'),
      closeTrivia: document.getElementById('closeTrivia'),
      modalMini: document.getElementById('modal-minigame'),
      miniBar: document.getElementById('miniBar'),
      miniTarget: document.getElementById('miniTarget'),
      miniCursor: document.getElementById('miniCursor'),
      miniStop: document.getElementById('miniStop'),
      miniFeedback: document.getElementById('miniFeedback'),
      closeMini: document.getElementById('closeMini'),
      modalEvent: document.getElementById('modal-event'),
      closeEvent: document.getElementById('closeEvent'),
      eventTone: document.getElementById('eventTone'),
      eventMessage: document.getElementById('eventMessage'),
      modalHelp: document.getElementById('modal-help'),
      closeHelp: document.getElementById('closeHelp'),
      modalTutorial: document.getElementById('modal-tutorial'),
      closeTutorial: document.getElementById('closeTutorial'),
      tutorialDone: document.getElementById('tutorialDone'),
      winnerName: document.getElementById('winnerName'),
      winnerMeta: document.getElementById('winnerMeta'),
      recordInfo: document.getElementById('recordInfo'),
      resultsList: document.getElementById('resultsList'),
      historyList: document.getElementById('historyList'),
      backToConfig: document.getElementById('backToConfig'),
      turnOverlay: document.getElementById('turnOverlay'),
      turnOverlayText: document.getElementById('turnOverlayText'),
      turnOverlayClose: document.getElementById('turnOverlayClose')
    };

    function init() {
      loadState();
      bindEvents();
      refreshPlayerInputs();
      render();
    }

    function loadState() {
      const saved = localStorage.getItem('heatSwimState');
      if (saved) {
        try {
          const data = JSON.parse(saved);
          state.config = { ...state.config, ...data.config };
          state.records = data.records || {};
          state.history = data.history || [];
        } catch (err) {
          console.error('Load failed', err);
        }
      }
      state.config.players = clamp(state.config.players || 2, 2, 4);
      dom.distance.value = state.config.distance;
      updateTurnCounts(state.config.turnCount);
      dom.energy.value = state.config.energy;
      dom.energyMax.value = state.config.energyMax;
      dom.players.value = state.config.players;
    }

    function saveState() {
      localStorage.setItem('heatSwimState', JSON.stringify({
        config: state.config,
        records: state.records,
        history: state.history
      }));
    }

    function bindEvents() {
      dom.distance.addEventListener('change', updateTurnCounts);
      dom.players.addEventListener('change', refreshPlayerInputs);
      dom.startGame.addEventListener('click', () => newGame(readConfig()));
      dom.resetData.addEventListener('click', resetData);
      dom.actionButtons.addEventListener('click', (event) => {
        const btn = event.target.closest('button');
        if (!btn) return;
        handleAction(btn.dataset.action);
      });
      dom.openHelp.addEventListener('click', () => openModal(dom.modalHelp));
      dom.openTutorial.addEventListener('click', () => openTutorial());
      dom.closeHelp.addEventListener('click', () => closeModal(dom.modalHelp));
      dom.closeTrivia.addEventListener('click', () => skipTrivia());
      dom.closeTutorial.addEventListener('click', () => closeTutorial());
      dom.tutorialDone.addEventListener('click', () => closeTutorial());
      dom.miniStop.addEventListener('click', () => stopMiniGame());
      dom.backToConfig.addEventListener('click', () => renderScreen('config'));
      dom.turnOverlayClose.addEventListener('click', () => closeTurnSummary());
      dom.closeEvent.addEventListener('click', () => closeModal(dom.modalEvent));
      document.addEventListener('keydown', handleKeydown);
    }

    function handleKeydown(event) {
      if (event.key === 'Escape') {
        if (dom.modalTrivia.classList.contains('active')) skipTrivia();
        if (dom.modalMini.classList.contains('active')) return;
        if (dom.modalEvent.classList.contains('active')) closeModal(dom.modalEvent);
        if (dom.modalHelp.classList.contains('active')) closeModal(dom.modalHelp);
        if (dom.modalTutorial.classList.contains('active')) closeTutorial();
        if (dom.turnOverlay.classList.contains('show')) closeTurnSummary();
      }
      if (dom.modalTutorial.classList.contains('active')) {
        if (event.key === 'Enter') {
          event.preventDefault();
          closeTutorial();
        }
        return;
      }
      if (state.screen !== 'game') return;
      if (dom.modalTrivia.classList.contains('active')) {
        if (event.key === 'Enter') {
          event.preventDefault();
          const btn = dom.triviaOptions.querySelector('button');
          if (btn) btn.focus();
        }
        return;
      }
      if (dom.modalMini.classList.contains('active')) {
        if (event.key === 'Enter') {
          event.preventDefault();
          stopMiniGame();
        }
        return;
      }
      if (event.key === '1') handleAction('soft');
      if (event.key === '2') handleAction('strong');
      if (event.key === '3') handleAction('sprint');
    }

    function refreshPlayerInputs() {
      const count = parseInt(dom.players.value, 10);
      dom.playerInputs.innerHTML = '';
      for (let i = 0; i < count; i += 1) {
        const wrapper = document.createElement('div');
        wrapper.innerHTML = `
          <label>Jugador ${i + 1}</label>
          <input type="text" data-player-name="${i}" placeholder="Nombre" value="Jugador ${i + 1}" />
        `;
        dom.playerInputs.appendChild(wrapper);
      }
    }

    function updateTurnCounts(preferred) {
      const distance = parseInt(dom.distance.value, 10);
      const minGap = 3;
      const maxTurns = Math.max(2, Math.min(4, Math.floor(distance / minGap) - 1));
      const counts = [];
      for (let i = 2; i <= maxTurns; i += 1) counts.push(i);
      dom.turnCount.innerHTML = '';
      counts.forEach((count) => {
        const opt = document.createElement('option');
        opt.value = count;
        opt.textContent = `${count} virajes`;
        dom.turnCount.appendChild(opt);
      });
      const pick = preferred && counts.includes(preferred) ? preferred : counts[0];
      dom.turnCount.value = pick;
      dom.turnIntervalHint.textContent = `Distancias aleatorias con m√≠nimo ${minGap} largos`;
    }

    function readConfig() {
      return {
        distance: parseInt(dom.distance.value, 10),
        turnCount: parseInt(dom.turnCount.value, 10),
        energy: parseInt(dom.energy.value, 10),
        energyMax: parseInt(dom.energyMax.value, 10),
        players: parseInt(dom.players.value, 10)
      };
    }

    function newGame(config) {
      state.config = config;
      state.players = [];
      state.log = [];
      state.blockedNext = {};
      state.blockReason = {};
      state.blockedSkip = {};
      state.turnLaps = [];
      state.currentIndex = 0;
      state.turnNumber = 1;
      state.awaiting = null;
      state.turnSummary = null;
      state.turnDifficulties = {};
      state.collectingSummary = false;
      state.turnSummaryLines = [];
      state.turnSummaryPlayer = null;
      state.activeTurnLap = null;
      clearTimeout(state.turnSummaryTimer);
      state.turnSummaryTimer = null;
      dom.turnOverlay.classList.remove('show');

      const nameInputs = dom.playerInputs.querySelectorAll('[data-player-name]');
      nameInputs.forEach((input, i) => {
        state.players.push(createPlayer(input.value.trim() || `Jugador ${i + 1}`, colors[i], icons[i], false));
      });

      state.turnLaps = generateTurnLaps(state.config.distance, state.config.turnCount);
      state.turnDifficulties = generateTurnDifficulties(state.turnLaps);

      saveState();
      renderScreen('game');
      render();
    }

    function createPlayer(name, color, icon) {
      return {
        name,
        color,
        icon,
        progress: 0,
        energy: state.config.energy,
        turns: 0,
        penalties: 0,
        bonus: 0
      };
    }

    function renderScreen(screenName) {
      state.screen = screenName;
      Object.keys(dom.screens).forEach((key) => {
        dom.screens[key].classList.toggle('active', key === screenName);
      });
    }

    function render() {
      if (state.screen === 'game') renderGame();
      if (state.screen === 'results') renderResults();
    }

    function renderGame() {
      dom.gameDistance.textContent = state.config.distance;
      dom.gameTurns.textContent = state.turnLaps.length;
      dom.trackDistance.textContent = state.config.distance;
      dom.turnList.textContent = `Virajes en: ${getTurnListText()} ¬∑ MAX 1/2/3 indica dificultad ¬∑ Sprint en viraje = zona m√°s dif√≠cil`;
      dom.turnName.textContent = currentPlayer().name;
      dom.turnCounter.textContent = `Turno ${state.turnNumber}`;
      const reason = state.blockReason?.[currentPlayer().name];
      dom.blockedHint.textContent = state.blockedNext[currentPlayer().name] ? `Bloqueado: solo Suave. ${reason || ''}` : '';
      applyActionPanelStyle(currentPlayer());

      renderTrack();

      if (state.blockedSkip[currentPlayer().name] && !state.awaiting) {
        const msg = reason ? `Turno bloqueado por exceso de velocidad. ${reason}. Pierdes el turno.` : 'Turno bloqueado por exceso de velocidad. Pierdes el turno.';
        state.blockedSkip[currentPlayer().name] = false;
        state.blockedNext[currentPlayer().name] = false;
        state.blockReason[currentPlayer().name] = '';
        showTurnSummary(`<div class="summary-line">${msg}</div>`);
      }

      dom.playerBoard.innerHTML = '';
      state.players.forEach((player, index) => {
        const card = document.createElement('div');
        card.className = 'player-card';
        const progressPct = Math.min(100, (player.progress / state.config.distance) * 100);
        card.innerHTML = `
          <div class="row space">
            <strong style="color:${player.color}">${player.icon} ${player.name}</strong>
            <span class="muted">${player.progress}/${state.config.distance} largos</span>
          </div>
          <div class="progress">
            <div class="fill" style="width:${progressPct}%; background:${player.color}"></div>
            <div class="marker" style="left:${progressPct}%"></div>
          </div>
          <div class="row">
            <span class="badge">Energ√≠a: ${player.energy}</span>
            <span class="badge">Turnos: ${player.turns}</span>
          </div>
        `;
        if (index === state.currentIndex) {
          card.style.border = `1px solid ${player.color}`;
          card.style.boxShadow = `0 0 12px ${player.color}55`;
        }
        dom.playerBoard.appendChild(card);
      });

      const locked = state.blockedNext[currentPlayer().name];
      const disabledAll = Boolean(state.awaiting);
      dom.actionButtons.querySelectorAll('button').forEach((btn) => {
        const action = btn.dataset.action;
        btn.disabled = disabledAll || (locked && action !== 'soft');
      });
      renderLog();
    }

    function renderLog() {
      dom.log.innerHTML = '';
      state.log.slice(-8).forEach((line) => {
        const div = document.createElement('div');
        div.className = 'log-line';
        div.textContent = line;
        dom.log.appendChild(div);
      });
    }

    function logEvent(message) {
      state.log.push(message);
      if (state.collectingSummary) state.turnSummaryLines.push(message);
      renderLog();
    }

    function startTurnSummary(player) {
      state.collectingSummary = true;
      state.turnSummaryLines = [];
      state.turnSummaryPlayer = player.name;
      state.turnSummary = {
        player: player.name,
        action: '',
        baseAdvance: 0,
        baseCost: 0,
        energyBefore: player.energy,
        energyAfter: player.energy,
        energySpent: 0,
        event: '',
        progressBefore: player.progress,
        progressAfter: player.progress,
        minigame: '',
        trivia: '',
        blockedReason: ''
      };
    }

    function showTurnSummary(text) {
      clearTimeout(state.turnSummaryTimer);
      state.awaiting = 'summary';
      const color = currentPlayer().color || '#35c6c6';
      dom.turnOverlay.style.borderColor = hexToRgba(color, 0.6);
      dom.turnOverlayText.innerHTML = text;
      dom.turnOverlay.classList.add('show');
      state.turnSummaryTimer = setTimeout(() => {
        closeTurnSummary();
      }, 15000);
    }

    function closeTurnSummary() {
      if (!dom.turnOverlay.classList.contains('show')) return;
      dom.turnOverlay.classList.remove('show');
      state.awaiting = null;
      clearTimeout(state.turnSummaryTimer);
      state.turnSummaryTimer = null;
      nextTurn();
    }

    function finishTurn() {
      const winner = state.players.find((p) => p.progress >= state.config.distance);
      if (winner) {
        finishGame();
        return;
      }
      state.collectingSummary = false;
      if (state.turnSummary) {
        state.turnSummary.progressAfter = currentPlayer().progress;
        const s = state.turnSummary;
        const lines = [];
        lines.push(`Acci√≥n: <strong>${s.action}</strong> (+${s.baseAdvance} largos)`);
        lines.push(`Energ√≠a: ${s.energyBefore} ‚Üí ${s.energyAfter} (‚àí${s.energySpent})`);
        if (s.event) lines.push(`Evento: ${s.event}`);
        lines.push(`Avance total: ${s.progressBefore} ‚Üí ${s.progressAfter}`);
        if (s.minigame) lines.push(`Viraje: ${s.minigame}`);
        if (s.trivia) lines.push(`Trivia: ${s.trivia}`);
        if (s.blockedReason) lines.push(`Castigo: Bloqueo pr√≥ximo turno (${s.blockedReason})`);
        const summaryHtml = lines.map((l) => `<div class="summary-line">${l}</div>`).join('');
        showTurnSummary(summaryHtml);
      } else {
        const playerName = state.turnSummaryPlayer || currentPlayer().name;
        showTurnSummary(`<div class="summary-line">${playerName} termina su turno.</div>`);
      }
    }
    function currentPlayer() {
      return state.players[state.currentIndex];
    }

    function nextTurn() {
      state.awaiting = null;
      state.currentIndex = (state.currentIndex + 1) % state.players.length;
      state.turnNumber += 1;
      render();
    }

    function handleAction(action) {
      if (state.awaiting) return;
      const player = currentPlayer();
      applyAction(action);
    }

    function applyAction(action) {
      const player = currentPlayer();
      const locked = state.blockedNext[player.name];
      if (locked && action !== 'soft') {
        logEvent(`${player.name} est√° bloqueado y solo puede Suave.`);
        return;
      }

      startTurnSummary(player);

      const actionMap = {
        soft: { advance: 1, cost: 0, label: 'Suave' },
        strong: { advance: 2, cost: 1, label: 'Fuerte' },
        sprint: { advance: 3, cost: 2, label: 'Sprint' }
      };

      const info = actionMap[action];
      if (!info) return;

      player.turns += 1;
      let advance = info.advance;
      let cost = info.cost;

      const beforeProgress = player.progress;
      const energyBefore = player.energy;
      player.energy = Math.max(0, player.energy - cost);
      logEvent(`${player.name} elige ${info.label} (+${advance} largos, -${cost} energ√≠a).`);

      const eventResult = maybeEvent(player, { advance, cost });
      advance = eventResult.advance;
      cost = eventResult.cost;
      const eventText = eventResult.eventText;
      const eventTone = eventResult.eventTone;
      if (eventText) showEventPopup(eventTone, eventText);

      player.progress = clamp(player.progress + advance, 0, state.config.distance);
      if (state.turnSummary) {
        state.turnSummary.action = info.label;
        state.turnSummary.baseAdvance = info.advance;
        state.turnSummary.baseCost = info.cost;
        state.turnSummary.energyBefore = energyBefore;
        state.turnSummary.energyAfter = player.energy;
        state.turnSummary.energySpent = Math.max(0, energyBefore - player.energy);
        state.turnSummary.event = eventText;
        state.turnSummary.progressBefore = beforeProgress;
        state.turnSummary.progressAfter = player.progress;
      }

      const energyDepleted = player.energy === 0;

      const crossedLap = getCrossedTurnLap(beforeProgress, player.progress, state.turnLaps);
      let overspeed = false;
      let maxSpeed = null;
      if (crossedLap) {
        maxSpeed = state.turnDifficulties[crossedLap] || 2;
        overspeed = info.advance > maxSpeed;
        if (overspeed) {
          logEvent(`Exceso en viraje (MAX ${maxSpeed}). Pr√≥ximo turno bloqueado.`);
          if (state.turnSummary) state.turnSummary.blockedReason = `Exceso en viraje (MAX ${maxSpeed})`;
        }
        state.activeTurnLap = crossedLap;
        startTurnMiniGame(player, action);
      }

      const blocked = energyDepleted || overspeed;
      state.blockedNext[player.name] = blocked;
      state.blockedSkip[player.name] = overspeed;
      state.blockReason[player.name] = overspeed ? `Exceso en viraje (MAX ${maxSpeed})` : energyDepleted ? 'Sin energ√≠a' : '';
      if (energyDepleted) logEvent(`${player.name} qued√≥ sin energ√≠a. Pr√≥ximo turno bloqueado.`);
      if (energyDepleted && state.turnSummary && !state.turnSummary.blockedReason) {
        state.turnSummary.blockedReason = 'Sin energ√≠a';
      }

      if (crossedLap) return;

      if (action === 'sprint') {
        const opened = maybeTrivia('sprint');
        if (opened) return;
      }

      finishTurn();
    }

    function maybeEvent(player, payload) {
      let { advance, cost } = payload;
      let eventText = '';
      let eventTone = 'neutral';
      const roll = Math.random();
      if (roll > 0.2) {
        logEvent('Carril limpio.');
        return { advance, cost, eventText, eventTone };
      }
      const eventPick = Math.random();
      if (eventPick < 0.33) {
        const delta = Math.random() < 0.5 ? 1 : -1;
        advance += delta;
        eventText = `Salida/ritmo: ${delta > 0 ? '+1' : '-1'} largo`;
        eventTone = delta > 0 ? 'good' : 'bad';
        logEvent(`${eventText}.`);
      } else if (eventPick < 0.66) {
        if (cost > 0) {
          cost += 1;
          player.energy = Math.max(0, player.energy - 1);
          eventText = 'Turbulencia: +1 energ√≠a';
          eventTone = 'bad';
          logEvent(`${eventText}.`);
        } else {
          advance -= 1;
          eventText = 'Turbulencia: -1 largo';
          eventTone = 'bad';
          logEvent(`${eventText}.`);
        }
      } else {
        logEvent('Carril limpio.');
      }
      advance = clamp(advance, 0, state.config.distance - player.progress);
      return { advance, cost, eventText, eventTone };
    }

    function crossedTurn(before, after, interval) {
      const beforeBlock = Math.floor(before / interval);
      const afterBlock = Math.floor(after / interval);
      return afterBlock > beforeBlock;
    }

    function startTurnMiniGame(player, action) {
      state.awaiting = 'minigame';
      openModal(dom.modalMini);
      const activeLap = state.activeTurnLap || null;
      const turnDiff = activeLap ? (state.turnDifficulties[activeLap] || 2) : 2;
      const diffLabel = turnDiff === 1 ? 'suave' : turnDiff === 2 ? 'media' : 'cerrada';
      dom.miniFeedback.textContent = `Curva ${diffLabel}. ${action === 'sprint' ? 'Sprint = zona m√°s peque√±a.' : ''}`;

      const difficultyMap = {
        1: { width: 34, speed: 0.17 },
        2: { width: 28, speed: 0.2 },
        3: { width: 24, speed: 0.22 }
      };
      const base = difficultyMap[turnDiff] || difficultyMap[2];
      let targetWidth = base.width;
      let finalSpeed = base.speed;
      if (action === 'sprint') {
        targetWidth = Math.max(16, targetWidth - 4);
        finalSpeed += 0.03;
      } else if (action === 'strong') {
        finalSpeed += 0.01;
      }
      const targetStart = 20 + Math.random() * 40;
      dom.miniTarget.style.left = `${targetStart}%`;
      dom.miniTarget.style.width = `${targetWidth}%`;

      let cursor = 0;
      let direction = 1;
      const startTime = performance.now();
      state.miniGame = {
        active: true,
        cursor,
        direction,
        startTime,
        targetStart,
        targetEnd: targetStart + targetWidth,
        timer: null
      };

      const step = (time) => {
        if (!state.miniGame || !state.miniGame.active) return;
        const elapsed = time - startTime;
        const speed = finalSpeed || 0.18;
        cursor += speed * direction * (time - (state.miniGame.lastTime || time));
        if (cursor >= 100) {
          cursor = 100;
          direction = -1;
        }
        if (cursor <= 0) {
          cursor = 0;
          direction = 1;
        }
        state.miniGame.lastTime = time;
        state.miniGame.cursor = cursor;
        state.miniGame.direction = direction;
        dom.miniCursor.style.left = `${cursor}%`;
        state.miniGame.timer = requestAnimationFrame(step);
      };
      state.miniGame.timer = requestAnimationFrame(step);
    }

    function stopMiniGame() {
      if (!state.miniGame || !state.miniGame.active) return;
      state.miniGame.active = false;
      cancelAnimationFrame(state.miniGame.timer);
      const cursor = state.miniGame.cursor;
      const success = cursor >= state.miniGame.targetStart && cursor <= state.miniGame.targetEnd;
      resolveTurnMiniGame(success);
    }

    function resolveTurnMiniGame(success) {
      const player = currentPlayer();
      if (success) {
        player.progress = clamp(player.progress + 1, 0, state.config.distance);
        logEvent(`Viraje exitoso: ${player.name} gana +1 largo y opci√≥n de trivia.`);
        dom.miniFeedback.textContent = '¬°Perfecto! +1 largo y trivia.';
        if (state.turnSummary) state.turnSummary.minigame = '√âxito (+1 largo)';
      } else {
        player.progress = clamp(player.progress - 1, 0, state.config.distance);
        logEvent(`Viraje fallido: ${player.name} pierde 1 largo.`);
        dom.miniFeedback.textContent = 'Fallo: -1 largo.';
        if (state.turnSummary) state.turnSummary.minigame = 'Fallo (-1 largo)';
      }
      closeModal(dom.modalMini);
      state.awaiting = null;
      if (success) {
        const opened = maybeTrivia('turn');
        if (opened) return;
      }
      state.activeTurnLap = null;
      finishTurn();
    }

    function maybeTrivia(trigger) {
      if (trigger === 'sprint' && Math.random() > 0.5) return false;
      const q = questions[Math.floor(Math.random() * questions.length)];
      state.trivia = q;
      dom.triviaCategory.textContent = q.cat;
      dom.triviaQuestion.textContent = q.q;
      dom.triviaOptions.innerHTML = '';
      dom.triviaFeedback.textContent = '';
      q.a.forEach((opt, index) => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = `${String.fromCharCode(65 + index)} ¬∑ ${opt}`;
        btn.addEventListener('click', () => resolveTrivia(index));
        dom.triviaOptions.appendChild(btn);
      });
      state.awaiting = 'trivia';
      openModal(dom.modalTrivia);
      return true;
    }

    function resolveTrivia(answer) {
      if (!state.trivia) return;
      const player = currentPlayer();
      if (answer === state.trivia.c) {
        player.energy = Math.min(state.config.energyMax, player.energy + 1);
        logEvent(`Trivia correcta: ${player.name} recupera +1 energ√≠a.`);
        dom.triviaFeedback.textContent = 'Correcto: +1 energ√≠a.';
        if (state.turnSummary) {
          state.turnSummary.trivia = 'Correcto (+1 energ√≠a)';
          state.turnSummary.energyAfter = player.energy;
          state.turnSummary.energySpent = Math.max(0, state.turnSummary.energyBefore - player.energy);
        }
      } else {
        logEvent(`Trivia fallida por ${player.name}.`);
        dom.triviaFeedback.textContent = 'Incorrecto. Sin castigo.';
        if (state.turnSummary) state.turnSummary.trivia = 'Incorrecto';
      }
      state.trivia = null;
      setTimeout(() => {
        closeModal(dom.modalTrivia);
        state.awaiting = null;
        finishTurn();
      }, 400);
      render();
    }

    function skipTrivia() {
      if (!state.trivia) {
        closeModal(dom.modalTrivia);
        state.awaiting = null;
        return;
      }
      logEvent(`${currentPlayer().name} cerr√≥ la trivia.`);
      if (state.turnSummary) state.turnSummary.trivia = 'Omitida';
      state.trivia = null;
      closeModal(dom.modalTrivia);
      state.awaiting = null;
      finishTurn();
    }

    function finishGame() {
      const sorted = [...state.players].sort((a, b) => {
        if (b.progress !== a.progress) return b.progress - a.progress;
        if (a.turns !== b.turns) return a.turns - b.turns;
        return b.energy - a.energy;
      });
      const winner = sorted[0];

      const recordKey = `${state.config.distance}-${state.players.length}`;
      const best = state.records[recordKey];
      if (!best || winner.turns < best.turns) {
        state.records[recordKey] = { name: winner.name, turns: winner.turns };
      }

      state.history.unshift({
        name: winner.name,
        date: new Date().toLocaleString('es-ES'),
        distance: state.config.distance,
        players: state.players.length
      });
      state.history = state.history.slice(0, 10);
      saveState();

      state.sortedResults = sorted;
      renderScreen('results');
      render();
    }

    function renderResults() {
      const winner = state.sortedResults[0];
      dom.winnerName.textContent = `Ganador: ${winner.name}`;
      dom.winnerMeta.textContent = `Turnos: ${winner.turns} ¬∑ Energ√≠a: ${winner.energy}`;

      const recordKey = `${state.config.distance}-${state.players.length}`;
      const record = state.records[recordKey];
      dom.recordInfo.textContent = record ? `R√©cord para ${state.config.distance} largos (${state.players.length} jugadores): ${record.name} con ${record.turns} turnos.` : 'Sin r√©cord a√∫n.';

      dom.resultsList.innerHTML = '';
      state.sortedResults.forEach((player, index) => {
        const row = document.createElement('div');
        row.className = 'result-row';
        row.innerHTML = `
          <span>${index + 1}. ${player.name}</span>
          <span>${player.turns} turnos ¬∑ ${player.energy} energ√≠a</span>
        `;
        dom.resultsList.appendChild(row);
      });

      dom.historyList.innerHTML = '';
      state.history.forEach((item) => {
        const row = document.createElement('div');
        row.className = 'result-row';
        row.innerHTML = `<span>${item.name}</span><span>${item.distance}L ¬∑ ${item.players} jug.</span>`;
        dom.historyList.appendChild(row);
      });
    }


    function resetData() {
      const ok = confirm('¬øSeguro que deseas borrar r√©cords e historial?');
      if (!ok) return;
      localStorage.removeItem('heatSwimState');
      localStorage.removeItem('heatSwimTutorialSeen');
      state.records = {};
      state.history = [];
      loadState();
      refreshPlayerInputs();
      render();
    }

    function openTutorial() {
      openModal(dom.modalTutorial);
    }

    function closeTutorial() {
      closeModal(dom.modalTutorial);
      localStorage.setItem('heatSwimTutorialSeen', '1');
    }

    function openModal(modal) {
      modal.classList.add('active');
    }

    function closeModal(modal) {
      modal.classList.remove('active');
    }

    function showEventPopup(tone, message) {
      dom.eventTone.textContent = tone === 'good' ? 'Perfecto' : tone === 'bad' ? 'Ups' : 'Evento';
      dom.eventTone.classList.toggle('bad', tone === 'bad');
      dom.eventMessage.textContent = message;
      openModal(dom.modalEvent);
      setTimeout(() => closeModal(dom.modalEvent), 1200);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function getNextTurnLap(progress, turnLaps) {
      for (let i = 0; i < turnLaps.length; i += 1) {
        if (turnLaps[i] > progress) return turnLaps[i];
      }
      return null;
    }

    function getCrossedTurnLap(before, after, turnLaps) {
      for (let i = 0; i < turnLaps.length; i += 1) {
        const lap = turnLaps[i];
        if (before < lap && after >= lap) return lap;
      }
      return null;
    }

    function applyActionPanelStyle(player) {
      const base = player.color || '#35c6c6';
      const bg = `linear-gradient(135deg, ${hexToRgba(base, 0.22)}, ${hexToRgba(base, 0.06)})`;
      dom.actionPanel.style.background = bg;
      dom.actionPanel.style.borderColor = hexToRgba(base, 0.45);
      dom.actionPanel.style.boxShadow = `0 0 18px ${hexToRgba(base, 0.2)}`;
    }

    function hexToRgba(hex, alpha) {
      const clean = hex.replace('#', '');
      const bigint = parseInt(clean, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function getTurnListText() {
      const laps = state.turnLaps;
      const parts = laps.map((lap) => `${lap}(MAX${state.turnDifficulties[lap] || 2})`);
      return parts.length ? parts.join(', ') : '‚Äî';
    }

    function generateTurnDifficulties(turnLaps) {
      const pattern = [1, 2, 3, 2];
      const difficulties = {};
      turnLaps.forEach((lap, idx) => {
        difficulties[lap] = pattern[idx % pattern.length];
      });
      return difficulties;
    }

    function generateTurnLaps(distance, turnCount) {
      const minGap = 3;
      const segments = turnCount + 1;
      let minSeg = minGap;
      if (segments * minSeg > distance) minSeg = 2;
      let remaining = distance - segments * minSeg;
      if (remaining < 0) remaining = 0;
      const segs = Array(segments).fill(minSeg);
      for (let i = 0; i < remaining; i += 1) {
        segs[Math.floor(Math.random() * segments)] += 1;
      }
      const laps = [];
      let acc = 0;
      for (let i = 0; i < segments - 1; i += 1) {
        acc += segs[i];
        if (acc < distance) laps.push(acc);
      }
      return laps;
    }

    function buildTrackLayout(distance, turnLaps) {
      const rows = Math.max(1, turnLaps.length + 1);
      const xLeft = 14;
      const xRight = 86;
      const yTop = 12;
      const yBottom = 88;
      const rowSpacing = rows > 1 ? (yBottom - yTop) / (rows - 1) : 0;
      const gap = 4;
      const curveOut = 3.5;
      const positions = [];
      const curveSegments = [];
      const curveMids = [];

      let d = '';
      for (let row = 0; row < rows; row += 1) {
        const dirRight = row % 2 === 0;
        const prevLap = row === 0 ? 0 : turnLaps[row - 1];
        const nextLap = row < turnLaps.length ? turnLaps[row] : distance;
        const segLen = Math.max(1, nextLap - prevLap);
        const count = Math.max(1, segLen);
        const xStart = dirRight ? xLeft + gap : xRight - gap;
        const xEnd = dirRight ? xRight - gap : xLeft + gap;
        const y = yBottom - row * rowSpacing;

        for (let step = 0; step < count; step += 1) {
          const ratio = count === 1 ? 0.5 : step / (count - 1);
          const x = lerp(xStart, xEnd, ratio);
          positions.push({ x, y });
        }

        if (row === 0) d = `M ${xStart} ${y}`;
        d += ` L ${xEnd} ${y}`;
        if (row < rows - 1) {
          const nextY = yBottom - (row + 1) * rowSpacing;
          const ctrlX = dirRight ? xRight + curveOut : xLeft - curveOut;
          const curvePath = `M ${xEnd} ${y} C ${ctrlX} ${y} ${ctrlX} ${nextY} ${xEnd} ${nextY}`;
          d += ` C ${ctrlX} ${y} ${ctrlX} ${nextY} ${xEnd} ${nextY}`;
          const lapAtEnd = turnLaps[row];
          if (lapAtEnd && lapAtEnd < distance) {
            const midX = xEnd * 0.25 + ctrlX * 0.75;
            const midYCurve = (y + nextY) / 2;
            curveMids.push({ lap: lapAtEnd, x: midX, y: midYCurve });
            curveSegments.push({ lap: lapAtEnd, path: curvePath, dirRight });
          }
        }
      }
      if (d) curveSegments.unshift({ lap: null, path: d, dirRight: true });

      const startPos = { x: (xLeft + gap) - 6, y: yBottom };
      positions.unshift(startPos);

      curveMids.forEach((entry) => {
        if (entry.lap > 0 && entry.lap < positions.length) {
          positions[entry.lap] = { x: entry.x, y: entry.y };
        }
      });

      return { positions, path: d, rows, curveSegments };
    }

    function renderTrack() {
      const distance = state.config.distance;
      const track = dom.trackBoard;
      track.innerHTML = '';
      const layout = buildTrackLayout(distance, state.turnLaps);
      const positions = layout.positions;
      const currentNextTurn = getNextTurnLap(currentPlayer().progress, state.turnLaps);
      const height = layout.rows <= 4 ? 420 : Math.min(700, 280 + layout.rows * 30);
      track.style.height = `${height}px`;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.classList.add('track-svg');
      svg.setAttribute('viewBox', '0 0 100 100');
      svg.setAttribute('preserveAspectRatio', 'none');

      const edge = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      edge.classList.add('track-path', 'edge');
      edge.setAttribute('d', layout.path);
      svg.appendChild(edge);

      const outer = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      outer.classList.add('track-path', 'outer');
      outer.setAttribute('d', layout.path);
      svg.appendChild(outer);

      layout.curveSegments
        .filter((seg) => seg.lap)
        .forEach((seg) => {
          const diff = state.turnDifficulties[seg.lap] || 2;
          const texture = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          texture.classList.add('track-path', 'turn-texture', diff === 1 ? 'soft' : diff === 2 ? 'medium' : 'hard');
          texture.setAttribute('d', seg.path);
          svg.appendChild(texture);
        });

      track.appendChild(svg);

      for (let lap = 1; lap <= distance; lap += 1) {
        const pos = positions[lap];
        const node = document.createElement('div');
        node.className = 'track-node';
        let diff = null;
        if (state.turnLaps.includes(lap)) {
          diff = state.turnDifficulties[lap] || 2;
          node.classList.add('turn', `diff-${diff}`);
        }
        if (currentNextTurn && lap === currentNextTurn) node.classList.add('next-turn');
        if (lap === distance) node.classList.add('finish');
        node.textContent = lap;
        node.style.left = `${pos.x}%`;
        node.style.top = `${pos.y}%`;
        track.appendChild(node);

        if (state.turnLaps.includes(lap)) {
          const limit = document.createElement('div');
          limit.className = 'turn-limit';
          limit.classList.add(`diff-${diff || 2}`);
          limit.textContent = `MAX ${diff}`;
          const idx = state.turnLaps.indexOf(lap);
          const offsetX = idx % 2 === 0 ? -18 : 18;
          const offsetY = -26;
          limit.style.left = `calc(${pos.x}% + ${offsetX}px)`;
          limit.style.top = `calc(${pos.y}% + ${offsetY}px)`;
          track.appendChild(limit);
        }
      }

      const startLabel = document.createElement('div');
      startLabel.className = 'track-label';
      startLabel.textContent = 'Inicio';
      startLabel.style.left = `${positions[0].x}%`;
      startLabel.style.top = `${positions[0].y - 6}%`;
      track.appendChild(startLabel);

      const finishLabel = document.createElement('div');
      finishLabel.className = 'track-label finish';
      finishLabel.textContent = 'Meta';
      finishLabel.style.left = `${positions[distance].x}%`;
      finishLabel.style.top = `${positions[distance].y + 6}%`;
      track.appendChild(finishLabel);

      const grouped = {};
      state.players.forEach((player) => {
        const lap = clamp(player.progress, 0, distance);
        if (!grouped[lap]) grouped[lap] = [];
        grouped[lap].push(player);
      });

      Object.keys(grouped).forEach((lapKey) => {
        const lapIndex = parseInt(lapKey, 10);
        const pos = positions[lapIndex];
        const players = grouped[lapKey];
        players.forEach((player, idx) => {
          const marker = document.createElement('div');
          marker.className = 'track-marker';
          if (player === currentPlayer()) marker.classList.add('current');
          marker.style.background = player.color;
          marker.textContent = player.icon || (idx + 1);
          const radius = players.length === 1 ? 0 : 18;
          const angle = players.length === 1 ? 0 : (idx / players.length) * Math.PI * 2;
          const offsetX = Math.cos(angle) * radius;
          const offsetY = Math.sin(angle) * radius;
          marker.style.left = `calc(${pos.x}% + ${offsetX}px)`;
          marker.style.top = `calc(${pos.y}% + ${offsetY}px)`;
          track.appendChild(marker);
        });
      });
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    init();
    if (localStorage.getItem('heatSwimTutorialSeen') !== '1') {
      setTimeout(() => openTutorial(), 150);
    }
  </script>
</body>
</html>
